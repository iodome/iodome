import{test as S}from"@playwright/test";import{spawn as x}from"child_process";import y from"http";import*as h from"net";import{createHash as E}from"crypto";import{readFileSync as T}from"fs";import*as c from"path";function D(){let t=process.argv.indexOf("--schema");return t!==-1&&process.argv[t+1]?c.resolve(process.argv[t+1]):process.env.PRISMA_SCHEMA_PATH?c.resolve(process.env.PRISMA_SCHEMA_PATH):c.join(process.cwd(),"prisma","schema.prisma")}function l(){try{let t=D(),e=T(t,"utf8");return`iodome_tpl_${E("sha256").update(e).digest("hex").slice(0,8)}`}catch{return"iodome_tpl_default"}}var r=class{static print=!!process.env.IODOME_DEBUG;static log(...e){this.print&&console.log("[iodome][LOG]",...e)}static warn(...e){this.print&&console.warn("[iodome][WARN]",...e)}static error(...e){this.print&&console.error("[iodome][ERROR]",...e)}};import{execSync as n}from"child_process";var a=class{static checkIfPostgresExists(){try{return n("psql -U postgres -c 'SELECT 1'",{stdio:"ignore"}),!0}catch{return!1}}static checkIfTemplateExists(e){let s=n(`psql -U postgres -tA -c "SELECT 1 FROM pg_database WHERE datname='${e}'"`,{encoding:"utf8",stdio:"pipe"}).toString().trim(),o=s.includes("1");return r.log(`Template existence check result: "${s}", exists: ${o}`),o}static createDatabase(e,s){r.log(`Creating database ${e}`),n(`psql -U postgres -c "CREATE DATABASE ${e}"`,{stdio:"ignore"}),r.log(`Running Prisma migrations for ${e}`),n(`DATABASE_URL=${s} pnpm prisma db push --accept-data-loss`,{stdio:"ignore"})}static createDatabaseFromTemplate(e,s){r.log(`Creating database ${e} using template ${s}`),n(`psql -U postgres -c "CREATE DATABASE ${e} TEMPLATE ${s}"`,{stdio:"ignore"}),r.log(`Database created from template for ${e}`)}static dropIodomeDatabases(){return n(`
		psql -U postgres -t -c "
			SELECT datname
			FROM pg_database
			WHERE datname LIKE 'iodome_test%';
		"
	`,{encoding:"utf-8"})}static dropDatabaseIfExists(e){n(`psql -U postgres -c "DROP DATABASE IF EXISTS ${e}"`,{stdio:"ignore"}),r.log(`Dropped test database: ${e}`)}static disconnectAllConnections(e){n(`
        psql -U postgres -c "
          SELECT pg_terminate_backend(pid)
          FROM pg_stat_activity
          WHERE datname = '${e}' AND pid <> pg_backend_pid();
        "
      `,{stdio:"ignore"})}};var p=class t{id;port;dbName;cmd;server;static instances=new Set;static cleanupSetup=!1;static templateDbName=null;static templateReady=!1;constructor(e){this.id=e.replace("-","_"),this.port=0,this.dbName="iodome_test",this.cmd=process.env.CI||process.env.IODOME_BUILD?"start":"dev",t.instances.add(this),this.setupGlobalCleanup()}async setup(){this.port=await this.getFreePort(),await this.setupDb(),r.log(`Starting server for test ${this.id} on port ${this.port}`),this.server=x("pnpm",[this.cmd],{env:{...process.env,DATABASE_URL:this.url,PORT:this.port.toString()},stdio:"ignore",detached:process.platform!=="win32"}),r.log(`Server process ${this.server.pid} started for test ${this.id}`),await this.waitForServerReady(this.port),r.log(`Server ready for test ${this.id}`)}setupGlobalCleanup(){if(t.cleanupSetup)return;t.cleanupSetup=!0;let e=()=>{let s=t.instances.size;s>0&&r.log(`Cleaning up ${s} test server${s===1?"":"s"}...`),t.instances.forEach(o=>{o.cleanup()})};process.once("SIGINT",()=>{e(),process.exit(0)}),process.once("SIGTERM",()=>{e(),process.exit(0)}),process.once("exit",e),process.once("uncaughtException",s=>{console.error("Uncaught exception:",s),e(),process.exit(1)}),process.once("unhandledRejection",s=>{console.error("Unhandled rejection:",s),e(),process.exit(1)})}async cleanup(){if(t.instances.delete(this),this.server&&!this.server.killed){r.log(`Killing server process ${this.server.pid}`);try{this.server.pid&&process.kill(-this.server.pid,"SIGTERM")}catch{this.server.kill("SIGTERM")}setTimeout(()=>{if(this.server&&!this.server.killed)try{this.server.pid&&process.kill(-this.server.pid,"SIGKILL")}catch{this.server.kill("SIGKILL")}},2e3)}this.cleanupDb()}get url(){return`postgresql://postgres:postgres@localhost:5432/${this.name}?schema=public`}get name(){return`${this.dbName}_${this.id}`}async getFreePort(){return new Promise((e,s)=>{let o=h.createServer();o.listen(0,()=>{let i=o.address();o.close(),i&&typeof i=="object"?e(i.port):s(new Error("Failed to acquire free port"))})})}static getTemplateDbNameCached(){return t.templateDbName||(t.templateDbName=l()),t.templateDbName}static checkTemplateExists(){if(t.templateReady)return!0;let e=t.getTemplateDbNameCached();try{return t.templateReady=a.checkIfTemplateExists(e),t.templateReady}catch{return!1}}async setupDb(){a.disconnectAllConnections(this.name),a.dropDatabaseIfExists(this.name);let e=t.checkTemplateExists();if(r.log(`
      Template exists: ${e},
      template name: ${t.templateDbName}
      `),e&&t.templateDbName)try{a.createDatabaseFromTemplate(this.name,t.templateDbName)}catch{r.log("Template creation failed, falling back to regular setup"),a.createDatabase(this.name,this.url)}else a.createDatabase(this.name,this.url);r.log(`Database setup complete for ${this.name}`)}cleanupDb(){try{a.disconnectAllConnections(this.name),a.dropDatabaseIfExists(this.name)}catch(e){r.warn(`Failed to drop test database ${this.name}:`,e)}}async waitForServerReady(e=6e4){let s=Date.now();return new Promise((o,i)=>{let m=()=>{let g=y.get(`http://127.0.0.1:${this.port}`,u=>{u.statusCode&&u.statusCode<500?o():d()});g.on("error",d),g.end()},d=()=>{Date.now()-s>e?i(new Error("Dev server did not become ready within the timeout period.")):setTimeout(m,100)};m()})}};function $(t){return`postgresql://postgres:postgres@localhost:5432/iodome_test_${t.replace("-","_")}?schema=public`}function f(t){return S.extend({baseURL:[async({},e,s)=>{let{testId:o}=s,i=new p(o);await i.setup(),await e(`http://127.0.0.1:${i.port}`),await i.cleanup()},{scope:"test",timeout:3e4}],prisma:[async({},e,s)=>{let{testId:o}=s,i=new t({datasources:{db:{url:$(o)}},log:process.env.DEBUG?["query","info","warn","error"]:[]});await e(i)},{scope:"test"}]})}async function b(){a.dropIodomeDatabases().split(`
`).map(s=>s.replace(/â”‚/g,"").trim()).filter(s=>s.length>0).filter(s=>s.includes("iodome_test")).forEach(s=>{a.disconnectAllConnections(s),a.dropDatabaseIfExists(s)})}import{afterEach as I,beforeEach as w}from"vitest";function v(t){w(async()=>{await t.$queryRaw`BEGIN;`}),I(async()=>{await t.$queryRaw`ROLLBACK;`})}export{f as createTestFixtures,b as dropDatabases,v as useTransactions};
//# sourceMappingURL=index.js.map